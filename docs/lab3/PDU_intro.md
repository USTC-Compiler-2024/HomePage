---
comments: true 
---

# <strong>PDU 使用手册</strong>

!!! Success "更新"

    2024-04-10 更新：将时钟频率降为 25MHz；增加了缓冲区大小。


## <strong>简介</strong>

PDU 是为了本学期组成原理实验而开发设计的板上控制单元。它可以接收来自用户的串口指令，将其解码并完成对应的操作，同时也可以获取 CPU 运行时的数据，并通过串口反馈给用户。

<figure markdown>
![Image title](./img/PDU.png){ width="600" }
<figcaption>项目的 TOP 框架</figcaption>
</figure>

!!! Bug "可能存在的问题"

    目前在串口写入时，如果序列过长，可能导致串口崩溃。如果遇到这种情况，请通过 sw7 手动刷新串口。正常情况下，每一次命令最后都会以 `User:` 的提示符结尾。如果遇到了其他问题，欢迎在本界面的评论区或 QQ 群中指出。


## <strong>支持命令</strong>

### <strong>串口读写命令</strong>

!!! Tips "提示"

    在使用 RI、RD、RR 命令时，可以在命令后面添加一个换行符 `\n`，从而避免出现乱码。例如：读取 32 个寄存器堆，可以输入 `RR 0 32;\n`（这里的 `\n` 是换行符！）。

!!! Info "RI [base]_16 [length]_10;"

    该命令从 base 地址开始，从<strong>指令</strong>存储器中读取连续的 length 个存储单元，并将结果显示在串口上。
    
    length 的长度不超过 64。

    ```
    e.g.    
        RI 0 10;
        将会显示 0x0~0x24 十个存储单元的数据
    ```

!!! Info "RD [base]_16 [length]_10;"

    该命令从 base 地址开始，从<strong>数据</strong>存储器中读取连续的 length 个存储单元，并将结果显示在串口上。

    length 的长度不超过 64。


!!! Info "RR [base]_16 [length]_10;"

    该命令从 base 地址开始从寄存器堆中读取连续的 length 个存储单元，并将结果显示在串口上。
    
    length 的长度不超过 64。

    ```
    e.g.    
        RR 0 10; 
        将会显示 R0 ~ R9 十个寄存器的数据
    ```



!!! Info "WI [base]_16 [length]_10 [code]_16;"

    该命令从 base 开始写入指令存储器连续的 length 个存储单元。后续的 code 以空格或换行符作为分隔，以分号结束。如果 code 的数目小于 length 的数目，则剩下的地址自动写 0。

    length 的长度无限制。

    ```
    e.g.    
        WI 0 2 1234 1235;
        写入操作为：
            M[0x0] <- 0x1234
            M[0x4] <- 0x1235

        WI 4 3 1234;
        写入操作为：
            M[0x4] <- 0x1234
            M[0x8] <- 0x0
            M[0xC] <- 0x0
    ```

    我们也可以使用换行代替空格。<strong>请注意：不能引入多余的空格，否则会导致解码器解码错误！</strong>

    ```
    e.g.
        WI 0 3
        1234
        1235
        1236;
        写入操作为：
            M[0x0] <- 0x1234
            M[0x4] <- 0x1235
            M[0x8] <- 0x1236
    ```

!!! Info "WD [base]_16 [length]_10 [code]_16;"

    该命令从 base 开始写入数据存储器连续的 length 个存储单元。后续的 code 以空格或换行符作为分隔，以分号结束。如果 code 的数目小于 length 的数目，则剩下的地址自动写 0。

    length 的长度无限制。


### <strong>断点命令</strong>

断点实现的基本原理是：当 CPU 产生 `commit` 信号时，PDU 会将 CPU 的 `commit_pc` 与 PDU 内部存储的断点进行比对，从而判断是否达到了断点。

!!! Info "BS [addr0]_16 [addr1]_16 [addr2]_16;"

    该命令会设置断点，后两个参数是可选的。PDU 允许至多设置三个不同的断点，并始终侦测 CPU 是否运行到了 bp0 的地址。
    断点无法被覆盖，只可以触发或删除。

    ```
    e.g.
        BS 1000 2000;

        会设置断点为 
            bp0 <- 0x1000
            bp1 <- 0x2000

        如果此时再次输入
        BS 3000 4000 5000;
        此时前两个断点地址已经被占用，故会设置断点为
            bp2 <- 0x3000

        如果 CPU 到达了 bp0 的地址，则接下来 bp0 会自动变为 bp1，bp1 会自动变为 bp2，bp2 会被自动清除。
        即：
            bp0 <- bp1
            bp1 <- bp2
            bp2 <- invalid
    ```

    

!!! Info "BL;"

    该命令可以查询当前已设置的断点。


!!! Info "BC;"

    该命令会清除所有的断点。


### <strong> CPU 命令</strong>

!!! Info "R;"

    连续运行命令。此时 CPU 将持续运行，直到达到断点、运行完成或用户中断。


!!! Info "S;"

    单步运行命令。


!!! Info "H;"

    强制停机命令。该命令将中断 CPU 的连续运行状态。


## <strong>MMIO</strong>

PDU 还提供了 MMIO 的功能。相关地址映射规则如下：

- 0xFFFF0008：该地址单元的低 8 位对应 led[7:0]。